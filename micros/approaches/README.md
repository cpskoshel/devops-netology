# Домашнее задание к занятию «Микросервисы: подходы»

>Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
>Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.


## Задача 1: Обеспечить разработку

>Предложите решение для обеспечения процесса разработки: хранение исходного кода, непрерывная интеграция и непрерывная поставка. 
>Решение может состоять из одного или нескольких программных продуктов и должно >описывать способы и принципы их взаимодействия.
>
>Решение должно соответствовать следующим требованиям:
>- облачная система;
>- система контроля версий Git;
>- репозиторий на каждый сервис;
>- запуск сборки по событию из системы контроля версий;
>- запуск сборки по кнопке с указанием параметров;
>- возможность привязать настройки к каждой сборке;
>- возможность создания шаблонов для различных конфигураций сборок;
>- возможность безопасного хранения секретных данных (пароли, ключи доступа);
>- несколько конфигураций для сборки из одного репозитория;
>- кастомные шаги при сборке;
>- собственные докер-образы для сборки проектов;
>- возможность развернуть агентов сборки на собственных серверах;
>- возможность параллельного запуска нескольких сборок;
>- возможность параллельного запуска тестов.
>
>Обоснуйте свой выбор.

## Ответ:
Учитывая потребности описанные выше предлагаю использовать решение [GitLab](https://about.gitlab.com).   
GitLab подходит под указанные требования, он позволяет закрыть полный цикл SDLC без необходимости интеграции разных систем между собой. (Нам не нужно настривать интгерации между хранилищем и сборщиком. Код, секреты, CI/CD, реестры Docker-образовнаходятся в одном месте)   
Для связи с K8s используется GitLab Agent for Kubernetes (Установливается внутри K8s-кластера)

Каждый микросервис размещается в отдельном репозитории GitLab (развернутый в контуре компании)(используется Git)
Настривается CI/CD (описывается в файле .gitlab-ci.yml расположенного внутри каждого репозитория. Сборку можно реализовать через тригеры запускаемые например по push модели. )    
Доставку конфигурации в K8s предлагаю реализовать через Helm-чарты, которые описываются в виде шаблонов и версионируются вместе с кодом.  
В процессе развертывания выполняется авторизация к API кластера K8s через GitLab Agent/токен. Далее обновление манифестовгде указывается ссылка на новый образ в GitLab Registry через команду helm upgrade --install. K8s получив команду скачивает новый образ и выполняет замену старых подов новыми (Rolling Update) В конце K8s проверяет состояние новых подов, при успешном трафик переключается на новую версию. В интерфейсе GitLab отображается состояние/статус деплоя.

---
## Задача 2: Логи

>Предложите решение для обеспечения сбора и анализа логов сервисов в микросервисной архитектуре.
>Решение может состоять из одного или нескольких программных продуктов и должно >описывать способы и принципы их взаимодействия.
>
>Решение должно соответствовать следующим требованиям:
>- сбор логов в центральное хранилище со всех хостов, обслуживающих систему;
>- минимальные требования к приложениям, сбор логов из stdout;
>- гарантированная доставка логов до центрального хранилища;
>- обеспечение поиска и фильтрации по записям логов;
>- обеспечение пользовательского интерфейса с возможностью предоставления >доступа разработчикам для поиска по записям логов;
>- возможность дать ссылку на сохранённый поиск по записям логов.
>
>Обоснуйте свой выбор.

## Ответ:
Предлагаю использовать стек Elasticsearch, Fluent Bit, Kibana где:    
Agent - Fluent Bit.  
Хранилище - Elasticsearch.    
Визуализация - Kibana.   

Решение выбрано по причинам:   
Соответсвует всем требованиям, широко используется и проверен временем выбранный стек. Минимальный Overhead, более глубокая аналитика, легко масштабируется.

Принцип работы:    
Как DaemonSet, Fluent Bit устанавливается в Kubernetes-кластер.     
После обработки Fluent Bit отправляет логи в Elasticsearch.    
Kibana подключается к Elasticsearch как графический интерфейс.

---

## Задача 3: Мониторинг

>Предложите решение для обеспечения сбора и анализа состояния хостов и сервисов >в микросервисной архитектуре.
>Решение может состоять из одного или нескольких программных продуктов и должно >описывать способы и принципы их взаимодействия.
>
>Решение должно соответствовать следующим требованиям:
>- сбор метрик со всех хостов, обслуживающих систему;
>- сбор метрик состояния ресурсов хостов: CPU, RAM, HDD, Network;
>- сбор метрик потребляемых ресурсов для каждого сервиса: CPU, RAM, HDD, Network;
>- сбор метрик, специфичных для каждого сервиса;
>- пользовательский интерфейс с возможностью делать запросы и агрегировать информацию;
>- пользовательский интерфейс с возможностью настраивать различные панели для >отслеживания состояния системы.
>
>Обоснуйте свой выбор.

## Ответ:
Предлагая юспользовать стек Prometheus, Node Exporter, cAdvisor, Grafana где:  
Prometheus - сбор метрик.  
Node Exporter - Агент.  
cAdvisor - сбор метрик потребления на уровне контейнеров.  
Grafana - Визуализация.  

Решение выбрано по причинам:   
Данная связка обеспечивт полную картину: от железа до  процесса внутри контейнера, с возможностью удобного анализа и оповещения о сбоях. Широко используемая имеет плагины и удобство в развертывании.   

Принцип работы:  
Node Exporter работает как DaemonSet на серверах (собирает метрики CPU, свободное место на дисках и другие)
cAdvisor встроен в K8s и его задача смотреть внутрь контейнеров и сколько CPU, памяти потребляет конкретный под сервиса.   
Сервисы могут отдавать бизнес-метрики через библиотеку Prometheus client

Prometheus работает по Pull модели. Он сам обходит все агенты (описаны выше) по заданному распиманию.   
С помощью Service Discovery, Prometheus автоматически находит новые поды опрашивая через API Kubernetes и сохраняет в базу Time Series DB, оптимизированную под быстрые графики.

Grafana подключается к Prometheus как к источнику данных.   
Внтри можно создавать дашборды и выводить всю необходимую информацию.



---


### Как оформить ДЗ?

>Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.
---
