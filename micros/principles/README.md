
# Домашнее задание к занятию «Микросервисы: принципы»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.

## Решение
---

| Возможности | Kong API Gateway | Tyk | Nginx | Traefik Proxy |
| ------- | ------- | ------- | ------- | ------- |
| Маршрутизация | Гибкая | Динамическая | Конфигурационные файлы | Динамическая |
| Аутентификация | Широкий выбор плагинов | Встроенная поддержка (JWT, OAuth2, Multi-auth) | Базовая или модули | Базовая |
| HTTPS Терминация | Да | Да | Да | Да |

Выбрано 4 популярных решения подходящие по требованиям. Каждый из них обладает своими преимуществами и недостатками.
Рекомендовал использовать Kong в связки с K8S (Высокая производительность, гибкость развертывания, легкость в масштабируемости, поддержка и популярность, наличие множества плагинов).

---

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.
---

## Решение
---
| Требования | RabbitMQ | Kafka | NATS JetStream |
| ------- | ------- | ------- | ------- |
| Поддержка кластеризации для обеспечения надёжности | ✅ Quorum Queues (высокая надежность) | ✅ Репликация разделов (отказоустойчивость) | ✅ RAFT-консолидация |
| Хранение сообщений на диске в процессе доставки | ✅ Да (индивидуально для очередей) | ✅ Да (Log-based, длительное хранение) | ✅ Да (File storage) |
| Высокая скорость работы | ⚠️ Средняя (~десятки тыс. msg/s) | ✅ Экстремальная (миллионы msg/s) | ✅ Высокая (сопоставима с Kafka) |
| Поддержка различных форматов сообщений | ✅ Любые (Binary, JSON, XML) | ✅ Любые (Binary, Avro, Protobuf) | ✅ Любые (Binary) |
| Разделение прав доступа к различным потокам сообщений | ✅ Гибкий RBAC (Vhosts, Tags) | ✅ ACL / SASL (сложная настройка) | ✅ Аккаунты и разрешения |
| Простота эксплуатации | ✅ Высокая (GUI, богатый CLI) | ❌ Низкая (Zookeeper/KRaft, JVM) | ✅ Очень высокая (один бинарный файл) |

Все решения активно используются, подробные документации, активно развиваются. Для выбора решения нужно более детальнне разобраться, так как каждое решение имеет свои преимущества и недостатки. Kafka отлично подходит для реализации "event-driven architecture" но не заточен под возврат сообщений в топик для повторной обработки сообщений. RabbitMq отлично работает с возвратом сообщений в очередь но не удобен для реализации "event-driven architecture".

---
